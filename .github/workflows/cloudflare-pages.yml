name: Deploy to Cloudflare Pages

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      debug:
        description: 'Enable debug logging'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  deployments: write
  pull-requests: write
  actions: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

env:
  NODE_VERSION: '20'
  CACHE_KEY_PREFIX: ${{ github.workflow }}-${{ github.ref }}

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    outputs:
      build-success: ${{ steps.build.outcome }}
      cache-hit: ${{ steps.cache-deps.outputs.cache-hit }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache npm dependencies
        id: cache-deps
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ env.CACHE_KEY_PREFIX }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ env.CACHE_KEY_PREFIX }}-npm-
            npm-

      - name: Cache build outputs
        uses: actions/cache@v4
        with:
          path: |
            dist
            .cache
          key: ${{ env.CACHE_KEY_PREFIX }}-build-${{ github.sha }}
          restore-keys: |
            ${{ env.CACHE_KEY_PREFIX }}-build-

      - name: Install dependencies
        id: install
        run: |
          echo "::group::Installing npm dependencies"
          npm ci --prefer-offline --no-audit --no-fund
          echo "::endgroup::"
        timeout-minutes: 5
        continue-on-error: false

      - name: Run type check
        run: npm run type-check

      - name: Run tests
        run: npm run test

      - name: Run database audit
        continue-on-error: true
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}
        run: |
          if [ -n "$VITE_SUPABASE_URL" ] && [ -n "$VITE_SUPABASE_ANON_KEY" ]; then
            node scripts/db-audit.mjs || echo "‚ö†Ô∏è DB audit failed (Supabase may be unreachable from CI); deploy continues"
          else
            echo "Skipping db audit (no Supabase credentials)"
          fi

      - name: Run lint
        run: npm run lint

      - name: Validate Supabase config (production build)
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}
        run: |
          if [ -n "$VITE_SUPABASE_ANON_KEY" ]; then
            if ! echo "$VITE_SUPABASE_ANON_KEY" | grep -q '^eyJ'; then
              echo "::error::VITE_SUPABASE_ANON_KEY must be the JWT anon key (starts with eyJ), not the publishable key. Get it from Supabase Dashboard ‚Üí Settings ‚Üí API ‚Üí anon public."
              echo "If you used sb_publishable_... or similar, replace with the long eyJ... token."
              exit 1
            fi
            echo "‚úì Supabase anon key format OK"
          else
            echo "‚ö†Ô∏è VITE_SUPABASE_ANON_KEY not set - production admin login will show paste-anon-key until configured"
          fi

      - name: Build application
        id: build
        env:
          VITE_BASE_PATH: /
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}
          VITE_ADMIN_ALLOWLIST_EMAILS: ${{ secrets.VITE_ADMIN_ALLOWLIST_EMAILS }}
          VITE_BREAK_GLASS_ADMIN_EMAIL: ${{ secrets.VITE_BREAK_GLASS_ADMIN_EMAIL }}
          VITE_ADMIN_OAUTH_REDIRECT_URL: ${{ secrets.VITE_ADMIN_OAUTH_REDIRECT_URL }}
          NODE_ENV: ${{ github.event.inputs.environment || 'production' }}
          DEBUG: ${{ github.event.inputs.debug && '*' || '' }}
        run: |
          echo "::group::Building application"
          npm run build 2>&1 | tee build.log
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          echo "::endgroup::"
          
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Build failed with exit code $BUILD_EXIT_CODE"
            cat build.log | tail -50
            exit 1
          fi
          
          echo "‚úÖ Build completed successfully"
          echo "Build output size: $(du -sh dist | cut -f1)"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: dist
          retention-days: 1
          if-no-files-found: error

      - name: Report build status
        if: always()
        run: |
          if [ "${{ steps.build.outcome }}" == "success" ]; then
            echo "‚úÖ Build job completed successfully"
          else
            echo "‚ùå Build job failed"
          fi

  # Uses GitHub environment "production". If that env has Required reviewers, this job will wait for approval (see DEBUG_DEPLOY.md).
  deploy:
    name: Deploy to Cloudflare Pages
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.deploy.outputs.deployment-url }}
    outputs:
      deployment-url: ${{ steps.deploy.outputs.deployment-url }}
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: dist

      - name: Require Cloudflare secrets
        run: |
          if [ -z "${{ secrets.CLOUDFLARE_API_TOKEN }}" ]; then
            echo "::error::CLOUDFLARE_API_TOKEN is not set. Add it in Settings ‚Üí Secrets and variables ‚Üí Actions (repository secrets). Token needs Account + Cloudflare Pages Edit."
            exit 1
          fi
          if [ -z "${{ secrets.CLOUDFLARE_ACCOUNT_ID }}" ]; then
            echo "::error::CLOUDFLARE_ACCOUNT_ID is not set. Add it in Settings ‚Üí Secrets and variables ‚Üí Actions (repository secrets)."
            exit 1
          fi
          echo "Cloudflare secrets are set."

      # Debug: print why deploy might not reach Cloudflare (no secret values logged)
      - name: Deploy diagnostics
        env:
          CF_TOKEN_SET: ${{ secrets.CLOUDFLARE_API_TOKEN != '' && 'set' || 'NOT SET' }}
          CF_ACCOUNT_SET: ${{ secrets.CLOUDFLARE_ACCOUNT_ID != '' && 'set' || 'NOT SET' }}
        run: |
          echo "::group::Deploy diagnostics"
          echo "event: ${{ github.event_name }} | ref: ${{ github.ref }} | sha: ${{ github.sha }}"
          echo "CLOUDFLARE_API_TOKEN: $CF_TOKEN_SET"
          echo "CLOUDFLARE_ACCOUNT_ID: $CF_ACCOUNT_SET"
          echo "command: pages deploy dist --project-name=lords-gym --branch=main"
          echo "If deploy job shows 'Waiting for approval', go to Settings ‚Üí Environments ‚Üí production and Approve or disable Required reviewers."
          echo "::endgroup::"

      - name: Deploy to Cloudflare Pages
        id: deploy
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy dist --project-name=lords-gym --branch=main
          gitHubToken: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify deployment (health check)
        id: health-check
        run: |
          DEPLOY_URL="${{ steps.deploy.outputs.deployment-url }}"
          echo "Checking deployment health: $DEPLOY_URL"
          if [ -z "$DEPLOY_URL" ] || [ "$DEPLOY_URL" = "undefined" ]; then
            echo "‚ö†Ô∏è No deployment URL available"
            exit 0
          fi
          
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOY_URL" || echo "000")
            
            if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "304" ]; then
              echo "‚úÖ Deployment healthy (HTTP $HTTP_STATUS)"
              echo "url=$DEPLOY_URL" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "‚è≥ Attempt $RETRY_COUNT/$MAX_RETRIES: HTTP $HTTP_STATUS, retrying in 10s..."
            sleep 10
          done
          
          echo "‚ö†Ô∏è Health check did not pass after $MAX_RETRIES attempts, but deployment may still be propagating"
          echo "url=$DEPLOY_URL" >> $GITHUB_OUTPUT
        continue-on-error: true

  e2e:
    name: E2E Production Tests
    needs: deploy
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      - run: npm ci --prefer-offline --no-audit --no-fund
      - name: Install Playwright browsers
        run: npx playwright install chromium --with-deps
      - name: Run E2E smoke tests
        env:
          PLAYWRIGHT_BASE_URL: https://lords-gym.pages.dev
          ADMIN_EMAIL: ${{ secrets.E2E_ADMIN_EMAIL }}
          ADMIN_PASSWORD: ${{ secrets.E2E_ADMIN_PASSWORD }}
          CI: true
        run: npm run test:e2e
        continue-on-error: true

  notify:
    name: Post Deployment Notification
    needs: [build, deploy]
    runs-on: ubuntu-latest
    if: always() && github.event_name == 'pull_request'
    steps:
      - name: Post PR comment with deployment URL
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const buildStatus = '${{ needs.build.result }}';
            const deployStatus = '${{ needs.deploy.result }}';
            const deployUrl = '${{ needs.deploy.outputs.deployment-url }}';
            
            let statusEmoji = '‚ùå';
            let statusText = 'Failed';
            
            if (buildStatus === 'success' && deployStatus === 'success') {
              statusEmoji = '‚úÖ';
              statusText = 'Success';
            } else if (buildStatus === 'success' && deployStatus === 'skipped') {
              statusEmoji = '‚ö†Ô∏è';
              statusText = 'Build Only (PR from fork)';
            } else if (buildStatus === 'cancelled' || deployStatus === 'cancelled') {
              statusEmoji = 'üö´';
              statusText = 'Cancelled';
            }
            
            const body = `## ${statusEmoji} Cloudflare Pages Deployment
            
            | Step | Status |
            |------|--------|
            | Build | ${buildStatus === 'success' ? '‚úÖ Success' : buildStatus === 'failure' ? '‚ùå Failed' : 'üö´ Cancelled'} |
            | Deploy | ${deployStatus === 'success' ? '‚úÖ Success' : deployStatus === 'skipped' ? '‚è≠Ô∏è Skipped' : deployStatus === 'failure' ? '‚ùå Failed' : 'üö´ Cancelled'} |
            
            ${deployUrl ? `**üöÄ Preview URL:** ${deployUrl}` : ''}
            
            <sub>Workflow run: [View logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})</sub>
            `;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Cloudflare Pages Deployment')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
              console.log('Updated existing PR comment');
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
              console.log('Created new PR comment');
            }

  report:
    name: Deployment Summary
    needs: [build, deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Output deployment summary
        run: |
          echo "## üìä Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build.result == 'success' && '‚úÖ Success' || needs.build.result == 'failure' && '‚ùå Failed' || 'üö´ Cancelled' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy | ${{ needs.deploy.result == 'success' && '‚úÖ Success' || needs.deploy.result == 'skipped' && '‚è≠Ô∏è Skipped' || needs.deploy.result == 'failure' && '‚ùå Failed' || 'üö´ Cancelled' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          DEPLOY_URL="${{ needs.deploy.outputs.deployment-url }}"
          if [ -n "$DEPLOY_URL" ]; then
            echo "**üöÄ Deployment URL:** $DEPLOY_URL" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ github.event.inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
